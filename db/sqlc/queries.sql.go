// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"time"
)

const getCurrentWallpaper = `-- name: GetCurrentWallpaper :one
SELECT
    path,
    set_at
FROM
    current_wallpaper
WHERE
    id = 1
`

type GetCurrentWallpaperRow struct {
	Path  string
	SetAt time.Time
}

func (q *Queries) GetCurrentWallpaper(ctx context.Context) (GetCurrentWallpaperRow, error) {
	row := q.db.QueryRowContext(ctx, getCurrentWallpaper)
	var i GetCurrentWallpaperRow
	err := row.Scan(&i.Path, &i.SetAt)
	return i, err
}

const getPreviousWallpaper = `-- name: GetPreviousWallpaper :one
SELECT
    id,
    path,
    set_at
FROM
    wallpaper_history
WHERE
    unset_at IS NOT NULL
ORDER BY
    unset_at DESC
LIMIT
    1
`

type GetPreviousWallpaperRow struct {
	ID    int64
	Path  string
	SetAt time.Time
}

func (q *Queries) GetPreviousWallpaper(ctx context.Context) (GetPreviousWallpaperRow, error) {
	row := q.db.QueryRowContext(ctx, getPreviousWallpaper)
	var i GetPreviousWallpaperRow
	err := row.Scan(&i.ID, &i.Path, &i.SetAt)
	return i, err
}

const getWallpaperHistory = `-- name: GetWallpaperHistory :many
SELECT
    id,
    path,
    set_at,
    unset_at
FROM
    wallpaper_history
WHERE
    (
        ? IS NULL
        OR set_at >= ?
    )
    AND (
        ? IS NULL
        OR id <= ?
    )
ORDER BY
    set_at DESC
LIMIT
    ?
`

type GetWallpaperHistoryParams struct {
	Column1 interface{}
	SetAt   time.Time
	Column3 interface{}
	ID      int64
	Limit   int64
}

func (q *Queries) GetWallpaperHistory(ctx context.Context, arg GetWallpaperHistoryParams) ([]WallpaperHistory, error) {
	rows, err := q.db.QueryContext(ctx, getWallpaperHistory,
		arg.Column1,
		arg.SetAt,
		arg.Column3,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WallpaperHistory
	for rows.Next() {
		var i WallpaperHistory
		if err := rows.Scan(
			&i.ID,
			&i.Path,
			&i.SetAt,
			&i.UnsetAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWallpaperHistory = `-- name: InsertWallpaperHistory :exec
INSERT INTO
    wallpaper_history (path, set_at)
VALUES
    (?, ?)
`

type InsertWallpaperHistoryParams struct {
	Path  string
	SetAt time.Time
}

func (q *Queries) InsertWallpaperHistory(ctx context.Context, arg InsertWallpaperHistoryParams) error {
	_, err := q.db.ExecContext(ctx, insertWallpaperHistory, arg.Path, arg.SetAt)
	return err
}

const markWallpaperUnset = `-- name: MarkWallpaperUnset :exec
UPDATE
    wallpaper_history
SET
    unset_at = ?
WHERE
    path = ?
    AND unset_at IS NULL
`

type MarkWallpaperUnsetParams struct {
	UnsetAt *time.Time
	Path    string
}

func (q *Queries) MarkWallpaperUnset(ctx context.Context, arg MarkWallpaperUnsetParams) error {
	_, err := q.db.ExecContext(ctx, markWallpaperUnset, arg.UnsetAt, arg.Path)
	return err
}

const updateCurrentWallpaper = `-- name: UpdateCurrentWallpaper :one
INSERT
    OR REPLACE INTO current_wallpaper (id, path, set_at)
VALUES
    (1, ?, ?)
RETURNING
    path,
    set_at
`

type UpdateCurrentWallpaperParams struct {
	Path  string
	SetAt time.Time
}

type UpdateCurrentWallpaperRow struct {
	Path  string
	SetAt time.Time
}

func (q *Queries) UpdateCurrentWallpaper(ctx context.Context, arg UpdateCurrentWallpaperParams) (UpdateCurrentWallpaperRow, error) {
	row := q.db.QueryRowContext(ctx, updateCurrentWallpaper, arg.Path, arg.SetAt)
	var i UpdateCurrentWallpaperRow
	err := row.Scan(&i.Path, &i.SetAt)
	return i, err
}
